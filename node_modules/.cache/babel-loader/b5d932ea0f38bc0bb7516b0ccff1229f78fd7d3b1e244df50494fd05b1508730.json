{"ast":null,"code":"import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n  #carryoverConcurrencyCount;\n  #isIntervalIgnored;\n  #intervalCount = 0;\n  #intervalCap;\n  #interval;\n  #intervalEnd = 0;\n  #intervalId;\n  #timeoutId;\n  #queue;\n  #queueClass;\n  #pending = 0;\n  // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n  #concurrency;\n  #isPaused;\n  #throwOnTimeout;\n  /**\n  Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n   Applies to each future operation.\n  */\n  timeout;\n  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n  constructor(options) {\n    super();\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    options = {\n      carryoverConcurrencyCount: false,\n      intervalCap: Number.POSITIVE_INFINITY,\n      interval: 0,\n      concurrency: Number.POSITIVE_INFINITY,\n      autoStart: true,\n      queueClass: PriorityQueue,\n      ...options\n    };\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n    }\n    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n    }\n    this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n    this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n    this.#intervalCap = options.intervalCap;\n    this.#interval = options.interval;\n    this.#queue = new options.queueClass();\n    this.#queueClass = options.queueClass;\n    this.concurrency = options.concurrency;\n    this.timeout = options.timeout;\n    this.#throwOnTimeout = options.throwOnTimeout === true;\n    this.#isPaused = options.autoStart === false;\n  }\n  get #doesIntervalAllowAnother() {\n    return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n  }\n  get #doesConcurrentAllowAnother() {\n    return this.#pending < this.#concurrency;\n  }\n  #next() {\n    this.#pending--;\n    this.#tryToStartAnother();\n    this.emit('next');\n  }\n  #onResumeInterval() {\n    this.#onInterval();\n    this.#initializeIntervalIfNeeded();\n    this.#timeoutId = undefined;\n  }\n  get #isIntervalPaused() {\n    const now = Date.now();\n    if (this.#intervalId === undefined) {\n      const delay = this.#intervalEnd - now;\n      if (delay < 0) {\n        // Act as the interval was done\n        // We don't need to resume it here because it will be resumed on line 160\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n      } else {\n        // Act as the interval is pending\n        if (this.#timeoutId === undefined) {\n          this.#timeoutId = setTimeout(() => {\n            this.#onResumeInterval();\n          }, delay);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n  #tryToStartAnother() {\n    if (this.#queue.size === 0) {\n      // We can clear the interval (\"pause\")\n      // Because we can redo it later (\"resume\")\n      if (this.#intervalId) {\n        clearInterval(this.#intervalId);\n      }\n      this.#intervalId = undefined;\n      this.emit('empty');\n      if (this.#pending === 0) {\n        this.emit('idle');\n      }\n      return false;\n    }\n    if (!this.#isPaused) {\n      const canInitializeInterval = !this.#isIntervalPaused;\n      if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n        const job = this.#queue.dequeue();\n        if (!job) {\n          return false;\n        }\n        this.emit('active');\n        job();\n        if (canInitializeInterval) {\n          this.#initializeIntervalIfNeeded();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n  #initializeIntervalIfNeeded() {\n    if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n      return;\n    }\n    this.#intervalId = setInterval(() => {\n      this.#onInterval();\n    }, this.#interval);\n    this.#intervalEnd = Date.now() + this.#interval;\n  }\n  #onInterval() {\n    if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n      clearInterval(this.#intervalId);\n      this.#intervalId = undefined;\n    }\n    this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n    this.#processQueue();\n  }\n  /**\n  Executes all queued functions until it reaches the limit.\n  */\n  #processQueue() {\n    // eslint-disable-next-line no-empty\n    while (this.#tryToStartAnother()) {}\n  }\n  get concurrency() {\n    return this.#concurrency;\n  }\n  set concurrency(newConcurrency) {\n    if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n      throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n    }\n    this.#concurrency = newConcurrency;\n    this.#processQueue();\n  }\n  async #throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n      signal.addEventListener('abort', () => {\n        reject(signal.reason);\n      }, {\n        once: true\n      });\n    });\n  }\n  async add(function_, options = {}) {\n    options = {\n      timeout: this.timeout,\n      throwOnTimeout: this.#throwOnTimeout,\n      ...options\n    };\n    return new Promise((resolve, reject) => {\n      this.#queue.enqueue(async () => {\n        this.#pending++;\n        this.#intervalCount++;\n        try {\n          options.signal?.throwIfAborted();\n          let operation = function_({\n            signal: options.signal\n          });\n          if (options.timeout) {\n            operation = pTimeout(Promise.resolve(operation), {\n              milliseconds: options.timeout\n            });\n          }\n          if (options.signal) {\n            operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n          }\n          const result = await operation;\n          resolve(result);\n          this.emit('completed', result);\n        } catch (error) {\n          if (error instanceof TimeoutError && !options.throwOnTimeout) {\n            resolve();\n            return;\n          }\n          reject(error);\n          this.emit('error', error);\n        } finally {\n          this.#next();\n        }\n      }, options);\n      this.emit('add');\n      this.#tryToStartAnother();\n    });\n  }\n  async addAll(functions, options) {\n    return Promise.all(functions.map(async function_ => this.add(function_, options)));\n  }\n  /**\n  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n  */\n  start() {\n    if (!this.#isPaused) {\n      return this;\n    }\n    this.#isPaused = false;\n    this.#processQueue();\n    return this;\n  }\n  /**\n  Put queue execution on hold.\n  */\n  pause() {\n    this.#isPaused = true;\n  }\n  /**\n  Clear the queue.\n  */\n  clear() {\n    this.#queue = new this.#queueClass();\n  }\n  /**\n  Can be called multiple times. Useful if you for example add additional items at a later time.\n   @returns A promise that settles when the queue becomes empty.\n  */\n  async onEmpty() {\n    // Instantly resolve if the queue is empty\n    if (this.#queue.size === 0) {\n      return;\n    }\n    await this.#onEvent('empty');\n  }\n  /**\n  @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n   If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n   Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n  */\n  async onSizeLessThan(limit) {\n    // Instantly resolve if the queue is empty.\n    if (this.#queue.size < limit) {\n      return;\n    }\n    await this.#onEvent('next', () => this.#queue.size < limit);\n  }\n  /**\n  The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n   @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n  */\n  async onIdle() {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this.#pending === 0 && this.#queue.size === 0) {\n      return;\n    }\n    await this.#onEvent('idle');\n  }\n  async #onEvent(event, filter) {\n    return new Promise(resolve => {\n      const listener = () => {\n        if (filter && !filter()) {\n          return;\n        }\n        this.off(event, listener);\n        resolve();\n      };\n      this.on(event, listener);\n    });\n  }\n  /**\n  Size of the queue, the number of queued items waiting to run.\n  */\n  get size() {\n    return this.#queue.size;\n  }\n  /**\n  Size of the queue, filtered by the given options.\n   For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n  */\n  sizeBy(options) {\n    // eslint-disable-next-line unicorn/no-array-callback-reference\n    return this.#queue.filter(options).length;\n  }\n  /**\n  Number of running items (no longer in the queue).\n  */\n  get pending() {\n    return this.#pending;\n  }\n  /**\n  Whether the queue is currently paused.\n  */\n  get isPaused() {\n    return this.#isPaused;\n  }\n}","map":{"version":3,"names":["EventEmitter","pTimeout","TimeoutError","PriorityQueue","PQueue","carryoverConcurrencyCount","isIntervalIgnored","intervalCount","intervalCap","interval","intervalEnd","intervalId","timeoutId","queue","queueClass","pending","concurrency","isPaused","throwOnTimeout","timeout","constructor","options","Number","POSITIVE_INFINITY","autoStart","TypeError","toString","undefined","isFinite","doesIntervalAllowAnother","#doesIntervalAllowAnother","doesConcurrentAllowAnother","#doesConcurrentAllowAnother","next","#next","tryToStartAnother","emit","onResumeInterval","#onResumeInterval","onInterval","initializeIntervalIfNeeded","isIntervalPaused","#isIntervalPaused","now","Date","delay","setTimeout","#tryToStartAnother","size","clearInterval","canInitializeInterval","job","dequeue","#initializeIntervalIfNeeded","setInterval","#onInterval","processQueue","#processQueue","newConcurrency","throwOnAbort","#throwOnAbort","signal","Promise","_resolve","reject","addEventListener","reason","once","add","function_","resolve","enqueue","throwIfAborted","operation","milliseconds","race","result","error","addAll","functions","all","map","start","pause","clear","onEmpty","onEvent","onSizeLessThan","limit","onIdle","#onEvent","event","filter","listener","off","on","sizeBy","length"],"sources":["/home/meghnab/Desktop/back/attendance_system/node_modules/p-queue/dist/index.js"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}